load model-checker.maude

fth NAT* is
protecting NAT .
op k : -> NzNat .
endfth

fmod NAT/{k :: NAT*} is
sort Nat/{k} .
op [_] : Nat -> Nat/{k} .
var N : Nat .
ceq [N] = [sd(N, k)] if N >= k .

var M : Nat .
op _<_ : Nat/{k} Nat/{k} -> Bool .
ceq [N] < [M] = true if sd(N, k) < sd(M, k) .
endfm

fmod QUEUE/{P :: NAT*} is
pr NAT/{P} .
sort Queue .
subsort Nat/{P} < Queue .
op nilQueue : -> Queue .
op __ : Queue Queue -> Queue [ctor assoc id: nilQueue] .
endfm

mod DINING-PHILOSOPHERS{P :: NAT*} is
protecting NAT/{P} .
protecting QUEUE/{P} .

sorts Status Philosopher Chopstick Configuration System .
subsort Philosopher Chopstick < Configuration .

op none : -> Configuration [ctor] .
op __ : Configuration Configuration -> Configuration [ctor assoc comm id: none] .
op philosopher : Nat/{P} Status Nat -> Philosopher [ctor] .
op chopstick : Nat/{P} -> Chopstick [ctor] .
op [_,_,_] : Configuration Queue Configuration -> System [ctor] .
op thinking : -> Status .
op eating : -> Status .
op hungry : -> Status .


var P1 : Nat .
var N : Nat .
var C : Nat .
var phil : Philosopher .
var chop : Chopstick .
var Q : Queue .
vars Conf1 Conf2 : Configuration .

var P : Philosopher .
op count : Configuration -> Nat .
eq count(none) = 0 .
eq count(P Conf2) = s (count(Conf2)) .

var K : Nat .
op initState : Nat -> Configuration .
eq initState(0) = none .
eq initState (s K) = chopstick([K]) philosopher([K], thinking, 0)  (initState(K)) .


rl [get-hungry] : [Conf1, Q, philosopher([P1], thinking, 0) Conf2] => [Conf1, Q, philosopher([P1], hungry, 0) Conf2] .
rl [in-queue] : [Conf1, Q, philosopher([P1], hungry, 0) Conf2] => [Conf1, [P1] Q, Conf2] .
crl [enter] : [Conf1, Q [P1], Conf2] => [Conf1 philosopher([P1], hungry, 0), Q, Conf2] if s count(Conf2) < k .
crl [grab-stick] : [Conf1 philosopher([P1], hungry, N) chopstick([C]), Q, Conf2] =>  [Conf1 philosopher([P1], hungry, s N), Q, Conf2]
if ([C] == [P1]) or ([C] == [s P1]) and (N < 2) .
rl [eat] : [Conf1 philosopher([P1], hungry, 2), Q, Conf2] => [Conf1 philosopher([P1], eating, 2), Q, Conf2] .
rl [think] : [Conf1 philosopher([P1], eating, 2), Q, Conf2] => [Conf1, Q, philosopher([P1], thinking, 0) Conf2] .

endm

view 5 from NAT* to INT is
op k to term 5 .
endv

mod DINING-PHILOSOPHERS-5 is
pr DINING-PHILOSOPHERS{5} .
endm

mod DINING-PHILOSOPHERS-PREDS{P :: NAT*} is
pr DINING-PHILOSOPHERS{P} .
inc SATISFACTION .
subsort Configuration < State .
op phil-status : Nat/{P} Status -> Prop .
op phil-sticks : Nat/{P} Nat -> Prop .
var N : Nat/{P} .
var S : Status .
var M : Nat .
var C : Configuration .
eq philosopher(N, S, M) C |= phil-status(N, S) = true .
eq philosopher(N, S, M) C |= phil-sticks(N, M) = true .
endm

mod DINING-PHILOSOPHERS-5-CHECK is
pr DINING-PHILOSOPHERS-PREDS{5} .
inc MODEL-CHECKER .
inc LTL-SIMPLIFIER .
endm