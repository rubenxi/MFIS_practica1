load model-checker.maude

fth NAT* is
protecting NAT .
op k : -> NzNat .
endfth

fmod NAT/{k :: NAT*} is
    sort Nat/{k} .
    op [_] : Nat -> Nat/{k} .
    var N : Nat .
    ceq [N] = [sd(N, k)] if N >= k .
endfm

fmod QUEUE/{P :: NAT*} is
    protecting NAT/{P} .

    sort Queue .
    subsort Nat/{P} < Queue .
    op nilQueue : -> Queue [ctor] .
    op __ : Queue Queue -> Queue [ctor assoc id: nilQueue] .
endfm

mod DINING-PHILOSOPHERS{P :: NAT*} is
    protecting NAT/{P} .
    protecting QUEUE/{P} .

    sorts Status Philosopher Chopstick Configuration System .
    subsort Philosopher Chopstick < Configuration .

    op none : -> Configuration [ctor] .
    op __ : Configuration Configuration -> Configuration [ctor assoc comm id: none] .

    op philosopher : Nat/{P} Status Nat -> Philosopher .
    op chopstick : Nat/{P} -> Chopstick .
    op [_,_,_] : Configuration Queue Configuration -> System [ctor] .

    op thinking : -> Status .
    op eating : -> Status .
    op hungry : -> Status .

    var N : Nat .
    var M : Nat .
    var C : Nat .
   
    var Q : Queue .
    vars T, T' : Configuration .

    var K : Nat .
    op initState : Nat -> System .
    eq initState(0) = [none, nilQueue, none] .
    eq initState (s K) = [chopstick([s K]) initChop(K) , nilQueue, philosopher([s K], thinking, 0) initPhil(K)] .
    
    op initChop : Nat -> Configuration .
    eq initChop (0) = none .
    eq initChop (s K) = chopstick([s K]) initChop(K) .

    op initPhil : Nat -> Configuration .
    eq initPhil(0) = none .
    eq initPhil(s K) = philosopher([s K], thinking, 0) initPhil(K) .

    var F : Philosopher .

    op count : Configuration -> Nat .
    eq count (none) = 0 .
    eq count (F T) = s count(T) .
    eq count (chopstick([N]) T) = count(T) .

    rl [get-hungry] : [T , Q , philosopher([N], thinking, 0) T'] => [T , Q , philosopher([N], hungry, 0) T'] .
    rl [enqueue] : [T , Q , philosopher([N], hungry, 0) T'] => [T ,[N] Q , T'] .
    crl [enter] : [T , Q [N], T'] => [ philosopher([N], hungry, 0) T , Q , T'] if s count(T) < k .
    crl [grab-stick] : [philosopher([N], hungry, C) chopstick([M]) T, Q, T'] => [philosopher([N], hungry, s C) T, Q, T'] if (([N] == [M]) or ([M] == [s N])) and (C < 2) .
    rl [eat] : [philosopher([N], hungry, 2) T, Q , T'] => [philosopher([N], eating, 2) T, Q , T'] .
    rl [think] : [philosopher([N], eating, 2) T, Q , T'] => [chopstick([N]) chopstick([s N]) T, Q , philosopher([N], thinking, 0) T'] .

endm

view 5 from NAT* to INT is
    op k to term 5 .
endv

mod DINING-PHILOSOPHERS-5 is
    pr DINING-PHILOSOPHERS{5} .
endm

mod DINING-PHILOSOPHERS-PREDS{P :: NAT*} is
    pr DINING-PHILOSOPHERS{P} .
    inc SATISFACTION .

    subsort System < State .

    op phil-status : Nat/{P} Status -> Prop .
    op phil-sticks : Nat/{P} Nat -> Prop .
    
    var N : Nat/{P} .
    var S : Status .
    var Q : Queue .
    var M : Nat .
    var C : Configuration .
    var C' : Configuration .
    eq [philosopher(N, S, M) C, Q, C'] |= phil-status(N, S) = true .
    eq [philosopher(N, S, M) C, Q, C'] |= phil-sticks(N, M) = true .
    eq [C, Q, philosopher(N, S, M) C'] |= phil-status(N, S) = true .
    eq [C, Q, philosopher(N, S, M) C'] |= phil-sticks(N, M) = true .
endm

mod DINING-PHILOSOPHERS-5-CHECK is
pr DINING-PHILOSOPHERS-PREDS{5} .
inc MODEL-CHECKER .
inc LTL-SIMPLIFIER .
endm